// Завдання 1
console.log("Завдання: 1 ==============================");

// Функція task1 не приймає жодних аргументів
function task1() {
  /**
   * Функція `getData` симулює отримання даних з асинхронного джерела,такого як запит до бази даних або API.
   *
   *  data - вхідні дані.
   *  timeout - час в мілісекундах, який витрачається на отримання даних,за замовчуванням 2000мс.
   */
  function getData(data, timeout = 2000) {
    // Функція повертає новий проміс
    return new Promise((resolve, reject) => {
      // За допомогою setTimeout ми симулюємо затримку timeout, яка виникає при роботі з асинхронними джерелами даних
      setTimeout(() => {
        // Якщо об'єкт не пустий, ми викликаємо resolve з data
        if (Object.keys(data).length) {
          resolve(data);
        } else {
          // Якщо об'єкт пустий, ми викликаємо reject з новим об'єктом Error("Об'єкт пустий")
          reject(new Error("Об'єкт пустий"));
        }
      }, timeout);
    });
  }

  // Ми викликаємо getData з об'єктом { name: "John", age: 30, city: "New York" } і часом очікування 2000
  let promise = getData({ name: "John", age: 30, city: "New York" }, 2000);

  // Ми обробляємо дані, повернуті промісом
  promise
    .then(
      // У разі успіху виводимо в консоль дані
      (data) => console.log(data),
      // У разі помилки виводимо повідомлення помилки
      (error) => console.log(error.message)
    )
    .finally(
      // Незалежно від того, завершилось виконання проміса успіхом чи ні виводимо в консоль "Завдання 1 завершено"
      () => console.log("Завдання 1 завершено")
    );
}

// Викликаємо функцію task1
task1();

// Завдання 2
console.log("Завдання: 2 ==============================");

// Створюємо функцію task2
function task2() {
  // Створюємо функцію promise1
  function promise1() {
    // Повертаємо новий проміс
    return new Promise((resolve) => {
      // Використовуємо setTimeout для імітації асинхронної операції, яка завершується через 2 секунди.
      setTimeout(() => {
        // Після 2 секунд викликаємо resolve з результатом проміса, який є рядком "Проміс 1 виконано"
        resolve("Проміс 1 виконано");
      }, 2000);
    });
  }

  // Створюємо функцію promise2
  function promise2() {
    // Повертаємо новий проміс
    return new Promise((resolve) => {
      // Використовуємо setTimeout для імітації асинхронної операції, яка завершується через 5 секунди.
      setTimeout(() => {
        // Після 5 секунд викликаємо resolve з результатом проміса, який є рядком "Проміс 2 виконано"
        resolve("Проміс 2 виконано");
      }, 5000);
    });
  }

  // Використовуємо Promise.race для визначення, який проміс виконується першим.
  // Метод повертає новий проміс, який вирішується або відхиляється негайно після розв'язання або відхилення будь-якого з промісів у переданому списку.
  Promise.race([promise1(), promise2()])
    .then(
      // У разі успіху виводимо результат
      (result) => console.log(result),
      // У разі помилки виводимо повідомлення про помилку
      (error) => console.log(error)
    )
    .finally(
      // Незалежно від результату, виводимо повідомлення про завершення обробки промісів, який є рядом "Завдання 2 завершено"
      () => console.log("Завдання 2 завершено")
    );
}

// Викликаємо функцію task2
task2();

// Завдання 3
console.log("Завдання: 3 ==============================");

// Створюємо функцію task3, в якій буде виконуватися завдання
function task3() {
  // Створюємо функцію promise1, яка створює і повертає новий проміс
  function promise1() {
    // Метод new Promise приймає в якості параметра функцію (executor), яка має два параметри: resolve і reject.
    return new Promise((resolve) => {
      // Використовуємо setTimeout для імітації асинхронної операції, яка завершується через 1 секунду
      setTimeout(() => {
        // Викликаємо resolve з рядком 'Проміс 1 виконано', що означає успішне вирішення проміса
        resolve("Проміс 1 виконано");
      }, 1000);
    });
  }

  // Створюємо функцію promise2, яка створює і повертає новий проміс, який відхиляється
  function promise2() {
    return new Promise((_, reject) => {
      // Використовуємо setTimeout для імітації асинхронної операції, яка не вдається і відхиляє проміс через 2 секунди
      setTimeout(() => {
        // Викликаємо reject з рядком 'Проміс 2 відхилено', що означає відхилення проміса
        reject("Проміс 2 відхилено");
      }, 2000);
    });
  }

  // Використовуємо Promise.allSettled який приймає масив промісів і повертає новий проміс, який вирішується, коли всі проміси вирішено або відхилено
  // Він повертає масив об'єктів, кожний з яких відображає стан кожного проміса
  Promise.allSettled([promise1(), promise2()])
    .then(
      // Функція then викликається, коли проміс вирішено
      // Вона приймає результати промісів і обробляє їх
      (results) =>
        results.forEach((result, index) => {
          // Для кожного результату виводимо статус проміса
          console.log(`Проміс ${index + 1}: ${result.status}`);
        })
    )
    .finally(
      // Функція finally викликається після того, як проміс вирішено або відхилено
      // Вона використовується для виконання дій, які повинні виконуватися незалежно від того, чи було проміс вирішено чи відхилено
      // В нашому випадку ми просто виводимо повідомлення, "Завдання 3 завершено"
      () => console.log("Завдання 3 завершено")
    );
}

// Викликаємо функцію task3, щоб виконати завдання
task3();

// Завдання 4
console.log("Завдання: 4 ==============================");

// Функція task4, яка буде використовувати проміси
function task4() {
  // Визначаємо перший проміс з іменем promise1
  // Функція promise1, повертає новий проміс
  function promise1() {
    // Ми викликаємо конструктор Promise, що приймає в якості аргументу функцію (executor function)
    // Ця функція приймає два аргументи: resolve і reject, які є функціями
    return new Promise((resolve) => {
      // Використовуємо функцію setTimeout, щоб симулювати асинхронну операцію
      // Ця функція приймає два аргументи: функцію, яку потрібно викликати після певного часу, і час у мілісекундах (1000 мс = 1 с)
      setTimeout(() => {
        // Після 1 секунди викликаємо функцію resolve, яка змінює стан проміса на "виконано" і передає значення 'Проміс 1 виконано'
        resolve("Проміс 1 виконано");
      }, 1000);
    });
  }

  // Визначаємо другий проміс з іменем promise2
  // Функція promise2, повертає новий проміс
  function promise2() {
    return new Promise((resolve) => {
      // Використовуємо функцію setTimeout, щоб симулювати асинхронну операцію з затримкою 1сек
      setTimeout(() => {
        // Після 1 секунди викликаємо функцію resolve, яка змінює стан проміса на "виконано" і передає значення 'Проміс 2 виконано'
        resolve("Проміс 2 виконано");
      }, 2000);
    });
  }

  // Promise.all приймає масив промісів і повертає новий проміс, який вирішується, коли всі вхідні проміси вирішені
  Promise.all([promise1(), promise2()])
    .then((results) => {
      // Функція then викликається, коли проміс вирішений
      // Результати всіх вхідних промісів передаються у функцію then у вигляді масиву, виводимо в консоль масив
      console.log(results); // ['Проміс 1 виконано', 'Проміс 2 виконано']
    })
    .catch((error) => {
      // Функція catch викликається, коли будь-який з промісів відхилено
      // Повідомлення про помилку від першого відхиленого проміса передається у функцію catch, виводимо в консоль помилку
      console.log(error);
    })
    .finally(() => {
      // Функція finally викликається незалежно від того, чи вирішено проміс, чи відхилено
      // Виводимо в консоль "Всі операції завершено"
      console.log("Всі операції завершено");
    });
}

// Викликаємо функцію task4
task4();

// Завдання 5
console.log("Завдання: 5 ==============================");

// Створюємо функцію task5, яка буде використовувати проміси.
function task5() {
  // Створюємо змінну counter яка буде лічильником та присвоюємо значення 0
  let counter = 0;

  // Створюємо проміс з іменем intervalPromise.
  const intervalPromise = new Promise((resolve, reject) => {
    // Використовуємо функцію setInterval, щоб імітувати асинхронну операцію яка повторюється кожну секунду
    let intervalId = setInterval(() => {
      // збільшуючи лічильник на 1
      counter++;
      // Виводимо в консоль `Значення лічильника: ${counter}`
      console.log(`Значення лічильника: ${counter}`);
      // Коли лічильник досягає 5, використовуємо clearInterval та викликаємо resolve, який повертає значення лічильника.
      if (counter >= 5) {
        clearInterval(intervalId);
        resolve(counter);
      }
    }, 1000);
  });

  intervalPromise
    // Використовуємо .then метод для отримання значення, яке було передане у функцію resolve() в нашому промісі, та виводимо його в консоль.
    .then((value) => console.log(value))
    // Використовуємо .catch метод для обробки випадків, коли проміс переходить в стан "rejected". Та виводимо в консоль помилку.

    .catch((error) => console.log(error)) // Обробляємо помилку, якщо вона виникне
    // Ми використовуємо .finally метод для виконання дій незалежно від того, в якому стані завершився наш проміс, та виводимо повідомлення "Завершення лічильника"

    .finally(() => console.log("Завершення лічильника")); // Виконуємо код після завершення проміса
}
// Викликаємо функцію task5
task5();

console.log("Завдання: 6 ==============================");

// Створюємо функцію task6, яка використовує setImmediate та проміси.
function task6() {
  // Створюємо новий проміс.
  const promise = new Promise((resolve, reject) => {
    // Використовуємо функцію setImmediate, щоб виконати функцію асинхронно.
    setImmediate(() => {
      // Генеруємо випадкове число від 0 до 1
      const randomNum = Math.random();
      // Якщо випадкове число менше 0.5, резолвимо проміс з рядком Більше ніж 0.5.
      if (randomNum < 0.5) {
        resolve("Більше ніж 0.5");
      } else {
        // Інакше відхиляемо проміс з рядком Менше ніж 0.5 .
        reject("Менше ніж 0.5");
      }
    });
  });

  promise
    // Використовуємо then для обробки зарезолвленого проміса, та виводимо `Проміс зарезолвився з значенням: ${value}`.

    .then((value) => console.log(`Проміс зарезолвився з значенням: ${value}`))
    // Якщо проміс відхилено, обробляємо помилку за допомогою catch, та виводимо `Проміс відхилився з помилкою: ${error}`.

    .catch((error) => console.log(`Проміс відхилився з помилкою: ${error}`))
    // Використовуємо finally для виконання дій після завершення проміса, незалежно від його статусу, та виводимо "Проміс завершено".

    .finally(() => console.log("Проміс завершено"));
}

// Викликаємо функцію task6
task6();

console.log("Завдання: 7 ==============================");

// Створюємо функцію task7, яка використовує setInterval та проміси.
function task7() {
  // Створюємо новий проміс.
  let promise = new Promise((resolve, reject) => {
    // Використовуємо функцію setInterval, щоб виконати функцію кожну секунду.
    let intervalId = setInterval(() => {
      // Отримаємо поточну дату та час
      const date = new Date();
      // Отримуємо секунди з поточної дати
      const seconds = date.getSeconds();
      // Виводимо в консоль повідомлення `Поточні секунди: ${seconds}`
      console.log(`Поточні секунди: ${seconds}`);

      // Якщо поточні секунди кратні 10, очищуємо інтервал та резолвимо проміс з рядком "Поточні секунди кратні 10!".
      if (seconds % 10 === 0) {
        clearInterval(intervalId);
        resolve("Поточні секунди кратні 10!");
      }

      // Якщо поточні секунди кратні 3, очищуємо інтервал та відхиляємо проміс з рядком "Поточні секунди кратні 3!".
      if (seconds % 3 === 0) {
        clearInterval(intervalId);
        reject("Поточні секунди кратні 3!");
      }
    }, 1000);
  });

  promise
    // Використовуємо then для обробки зарезолвленого проміса, та виводимо в консоль `Проміс зарезолвився з значенням: ${value}` .
    .then((value) => console.log(`Проміс зарезолвився з значенням: ${value}`))
    // Якщо проміс відхилено, обробляємо помилку за допомогою catch, та виводимо в консоль `Проміс відхилився з помилкою: ${error}`.
    .catch((error) => console.log(`Проміс відхилився з помилкою: ${error}`))
    // Використовуємо finally для виконання дій після завершення проміса, незалежно від його статусу, та виводимо в консоль "Проміс завершено".
    .finally(() => console.log("Проміс завершено"));
}

// Викликаємо функцію task7
task7();

console.log("Завдання: 8 ==============================");

function task8() {
  // Створюємо функцію fetchFakeData, яка симулює запит до сервера та повертає "дані" через Promise.resolve().
  function fetchFakeData() {
    // Створюємо fakeData константу з данними { name: "John",age: 30}
    const fakeData = {
      name: "John",
      age: 30,
    };

    // Використовуємо Promise.resolve(fakeData) для того, щоб створити вже зарезолвлений проміс.
    return Promise.resolve(fakeData);
  }

  // Викликаємо функцію fetchFakeData
  fetchFakeData()
    // Якщо проміс виконаний успішно виводимо в консоль дані які він повертає
    .then((data) => console.log(data))
    // Якщо проміс виконаний з помилкою виводимо в консоль помилку
    .catch((error) => console.log(error));
}
// Викликаємо функцію task8
task8();

console.log("Завдання: 9 ==============================");

function task9() {
  // Створюємо функцію fetchWithError, яка симулює помилку при запиті до сервера.
  function fetchWithError() {
    // Створюємо константу errorMessage в яку записуємо рядок "Помилка при з'єднанні з сервером"
    const errorMessage = "Помилка при з'єднанні з сервером";
    // Використовуємо Promise.reject(errorMessage) для створення вже відхиленого промісу.
    return Promise.reject(new Error(errorMessage));
  }

  // Викликаємо функцію fetchWithError

  fetchWithError()
    // Якщо проміс виконаний успішно виводимо в консоль дані які він повертає

    .then((data) => console.log(data))
    // Якщо проміс виконаний з помилкою виводимо в консоль помилку

    .catch((error) => console.log(error));
}

// Викликаємо функцію task9
task9();

console.log("Завдання: 10 ==============================");

function task10() {
  // Створюємо проміс promise1, які вирішуються через 500мс, та повертають як успішне виконання рядок "Promise 1".
  const promise1 = new Promise((resolve) =>
    setTimeout(resolve, 500, "Promise 1")
  );

  // Створюємо проміс promise2, які вирішуються через 200мс, та повертають як успішне виконання рядок "Promise 2".

  const promise2 = new Promise((resolve) =>
    setTimeout(resolve, 200, "Promise 2")
  );

  // Створюємо проміс promise3, які вирішуються через 300мс, та повертають як успішне виконання рядок "Promise 3".

  const promise3 = new Promise((resolve) =>
    setTimeout(resolve, 300, "Promise 3")
  );

  // Promise.any() приймає масив промісів які ми створили вище і вирішується, як тільки перший із цих промісів вирішується.
  Promise.any([promise1, promise2, promise3])
    // Якщо проміс виконаний успішно виводимо в консоль дані які він повертає
    .then((value) => console.log(value))
    // Якщо проміс виконаний з помилкою виводимо в консоль помилку
    .catch((error) => console.log(error));
}
// Викликаємо функцію task10
task10();
